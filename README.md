# Навігація по документу
- [Титулка](#титулка)
- [Вправа 1](#вправа-1-програмування-мовою-сi-використання-функцiй-стандартних-бiблiотек-sdtlibh-stringh-ctypeh-дляроботи-iз-текстовими-рядками)
- [Остаточний код](#осточний-код)
- [Компіляція коду](#компіляція-коду)
- [Висновок](#висновок)
- [Контрольнi питання](#контрольнi-питання)

## Титулка
<p align="center"><strong>МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
<br>НАЦІОНАЛЬНИЙ ТЕХНІЧНИЙ УНІВЕРСИТЕТ УКРАЇНИ
<br>«КИЇВСЬКИЙ ПОЛІТЕХНІЧНИЙ ІНСТИТУТ
<br> ІМЕНІ ІГОРЯ СІКОРСЬКОГО»
<br><br><br>Навчально-науковий інститут телекомунікаційних систем
<br><br>Кафедра телекомунікацій</strong>
<br><br><br><br><br>Дисципліна: «Інформатика. Частина 1.»
<br><strong>ПРОТОКОЛ ВИКОНАННЯ ЛАБОРАТОРНОЇ РОБОТИ № 7</strong> 
<br>Лабораторна робота 7. Функцiї в Сi.</p align="center">
<br><br><br><p align="right">Виконали студенти групи 
<br>ЦС-31 Бригада № 8:
<br>- Шваліковський Вадим
<br>- Шилан Владислав
<br>- Шумлянський Артем
<br>- Якимець Ігор
<br><br>Перевірила: 
<br>асистент кафедри ТК 
<br>Олена ФУРТАТ</p>
<br><br><br><p align="center"><strong>КИЇВ 2023</strong></p align="center">

## Вправа 1. Програмування мовою Сi: використання функцiй стандартних бiблiотек sdtlib.h, string.h, ctype.h дляроботи iз текстовими рядками
Завдання 1. Написати програми мовою програмування Сi вiдповiдно до свого варiанту та Додаткiв 1, 2. Протестувати, вiдлагодити програми i вивести в консоль результати обчислень.

**Додаток_1**

Завдання_№8

Визначити функцiю, яка замiнює слово iз вхiдного рядка на вказане нове слово (без аналiзу на прописнi i рядковi символи). В рядку може бути декiлька однакових слiв.
```
#include <stdio.h>
#include <string.h>

int main() {

    char inputString[250]; // Змінна рядка (речення)
    char oldWord[25]; // Змінна слова, яке потрібно замінити
    char newWord[25]; // Змінна нового слова, на яке потрібно замінити

    getchar(); // Очищення з пам'яті попередньо введених символів з клавіатури

    printf("Enter string(sentence): "); // Виведення тексту для введення рядка(речення)
    fgets(inputString, sizeof(inputString), stdin); // Зчитування введеного рядка(речення)
    inputString[strcspn(inputString, "\n")] = '\0';  // Створюємо рядковий масив

    printf("Enter the word you want to replace: "); // Виведення тексту для введення слова, яке потрібно замінити
    scanf("%s", oldWord); // Зчитування введеного слова

    printf("Enter new word: "); // Виведення тексту для введення нового слова
    scanf("%s", newWord); // Зчитування введеного слова

    char *pos = strstr(inputString, oldWord); // Створюємо вказівник, який знаходить і зберігає в собі старе слово

    while (pos != NULL) { //*Цикл для заміни слова*//
        memmove(pos + strlen(newWord), pos + strlen(oldWord), strlen(pos + strlen(oldWord)) + 1); // Замінюємо старе слово на нове
        strncpy(pos, newWord, strlen(newWord)); // Копіюємо нове слово в рядок 

        pos = strstr(pos + strlen(newWord), oldWord); // Перевіряємо рядок наявність ще старих слів
    }

    printf("Edited string(sentence): %s\n", inputString); // Виведення відредагованого рядка(речення)

    return 0;
}
```

**Додаток_2**

Завдання_№3

![Завдання_3](https://github.com/207art207/Informatika_Lab7/blob/main/Aditional_2%20task_3.png?raw=true)
```
#include <stdio.h>
#include <math.h>

int main() {

    int n = 1; // Змінна n(1)
    double ln2 = log(2); // Змінна ln(2)
    double EPS = pow(10, -6); // Змінна точності EPS
    double sum; // Змінна суми
    double sum1 = 1.0; // Змінна суми(1)
    

    while (fabs(sum1) > EPS) { /*Цикл для обчислення суми, поки сума не вийде за точність EPS*/
        sum += sum1; // Додавання всіх членів суми
        n++; // Перебір змінної n від 1 до нескінченності
        sum1 = pow(-1, n - 1) / (double)n; // Обчислення всіх членів суми 
    }

    printf("Sum = %lf\n", sum); // Виведення суми
    printf("ln(2) = %lf\n", ln2); // Виведення ln(2)

    return 0;
}
```

## Осточний код
```
#include <stdio.h>
#include <string.h>
#include <math.h>

int main () {
    while (1) { /*Нескінченний цикл для повторного запуску коду*/

    int t; // Змінна для вибору завдання

    printf ("Choose task:\n 1.Aditional_1 task_8\n 2.Aditional_2 task_3\n"); // Виведення тексту для вибору завдання
    scanf ("%d", &t); // Зчитування вибраного завдання з клавіатури

if (t==1) { /*Завдання 1*/
    
    char inputString[250]; // Змінна рядка (речення)
    char oldWord[25]; // Змінна слова, яке потрібно замінити
    char newWord[25]; // Змінна нового слова, на яке потрібно замінити

    getchar(); // Очищення з пам'яті попередньо введених символів з клавіатури

    printf("Enter string(sentence): "); // Виведення тексту для введення рядка(речення)
    fgets(inputString, sizeof(inputString), stdin); // Зчитування введеного рядка(речення)
    inputString[strcspn(inputString, "\n")] = '\0';  // Створюємо рядковий масив

    printf("Enter the word you want to replace: "); // Виведення тексту для введення слова, яке потрібно замінити
    scanf("%s", oldWord); // Зчитування введеного слова

    printf("Enter new word: "); // Виведення тексту для введення нового слова
    scanf("%s", newWord); // Зчитування введеного слова

    char *pos = strstr(inputString, oldWord); // Створюємо вказівник, який знаходить і зберігає в собі старе слово

    while (pos != NULL) { //*Цикл для заміни слова*//
        memmove(pos + strlen(newWord), pos + strlen(oldWord), strlen(pos + strlen(oldWord)) + 1); // Замінюємо старе слово на нове
        strncpy(pos, newWord, strlen(newWord)); // Копіюємо нове слово в рядок 

        pos = strstr(pos + strlen(newWord), oldWord); // Перевіряємо рядок наявність ще старих слів
    }

    printf("Edited string(sentence): %s\n", inputString); // Виведення відредагованого рядка(речення)
    }

if (t==2) { /*Завдання 2*/
    
    int n = 1; // Змінна n(1)
    double ln2 = log(2); // Змінна ln(2)
    double EPS = pow(10, -6); // Змінна точності EPS
    double sum; // Змінна суми
    double sum1 = 1.0; // Змінна суми(1)
    

    while (fabs(sum1) > EPS) { /*Цикл для обчислення суми, поки сума не вийде за точність EPS*/
        sum += sum1; // Додавання всіх членів суми
        n++; // Перебір змінної n від 1 до нескінченності
        sum1 = pow(-1, n - 1) / (double)n; // Обчислення всіх членів суми 
    }

    printf("Sum = %lf\n", sum); // Виведення суми
    printf("ln(2) = %lf\n", ln2); // Виведення ln(2)
    }
    
}
}
```
## Компіляція коду
![Компіляція коду](https://github.com/207art207/Informatika_Lab7/blob/main/Compilation_of_code.png?raw=true)
## Висновок
В ході лабораторної роботи ми покращили свої навички програмування на С.Ми навчилися використовувати функції. Вдосконалили навички використання бібліотеки math.h . Навчилися заміняти слова за допомогою функцій на C. За домогою функцій змогли порахувати суму нескінченного ряду. Обидва завдання виконані коректно і відповідають вимогам, поставленим у завданні. Функції реалізовані з використанням ефективних алгоритмів і протестовані на різних тестових випадках.
## Контрольнi питання
**1-2. Як оголосити користувацьку функцiю в Сi? Що означає тип функцiї?**

Для оголошення користувацької функції в мові програмування C існують певні правила:
- Тип повернення (return type): Це тип даних, який функція повертає. Якщо функція нічого не повертає, використовується ключове слово void.
- Ім'я функції.
- Параметри функції: Перелік змінних, які передаються у функцію. Кожен параметр має вказаний тип даних.
- Оголошення функції перед використанням: Зазвичай функцію слід оголошувати перед викликом нею в коді, щоб компілятор знав, як правильно обробляти виклики цієї функції.

Приклад:
```
void myFunction3(char param3, float param4); // Оголошення функції з параметрами, але без поверненого значення
```
**3. Що таке формальнi параметри i аргументи функцiї?**

Формальнi параметри й аргументи функцiї вказують на значення, які функція може отримати під час свого виклику.

1. Формальні параметри (Formal Parameters):
- Оголошені у визначенні функції.
- Це імена змінних, які використовуються всередині тіла функції.
-Вони слугують мовою програмування для визначення, які дані функція очікує отримати при виклику.
Приклад:
```
int add(int x, int y) { //add, x та y - це формальні параметри.
    return x + y;
}
```
2. Аргументи функції (Function Arguments):

- Передані під час виклику функції.
- Це конкретні значення чи вирази, які передаються функції при її виклику.
- Вони вказують на дані, які будуть використовуватися для обчислень у тілі функції.
Приклад:
```
int result = add(3, 5); // add, 3 та 5 - це аргументи функції.
```

**4-6. Методи передачi параметрiв в функцiю. Метод передачi параметрiв в функцiю за значенням. Продемонструвати на прикладi. Метод передачi параметрiв з використанням вказiвникiв. Продемонструвати на прикладi.**

1. Основні методи передачі параметрів:
- Передача за значенням (Pass by Value):
- У цьому методі значення аргументу копіюється у відповідний формальний параметр функції.
- Зміни, внесені в параметр усередині функції, не впливають на оригінальне значення аргументу.
- Це типовий метод передачі для простих типів даних, таких як цілі числа або дійсні числа.
Приклад:
```
void func(int x) {
    x = x + 1;
}

int main() {
    int num = 5;
    func(num);
    
    return 0; // Значення num залишиться 5, оскільки func працює з копією num
}

```
2. Передача за вказівником (Pass by Pointer):
- У цьому методі передається адреса аргументу, а не його значення.
- Функція отримує доступ до оригінального об'єкта через вказівник і може внести зміни в оригінальний об'єкт.
- Це може бути ефективний метод для передачі складних об'єктів.
Приклад:
```
void func(int *ptr) {
    (*ptr)++;
}

int main() {
    int num = 5;
    func(&num);
    
    return 0; // Значення num зміниться на 6, оскільки func працює з вказівником на num
}

```

**7. Як передати масив, як параметр в функцiю?**
Приклади як передати масив, як параметр у функцiю:
1. Передача за значенням:
У цьому випадку функція отримує копію початкового масиву, і зміни в масиві всередині функції не впливають на оригінал.
Приклад:
```
#include <stdio.h>

void modifyArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] *= 2;
    }
}

int main() {
    int myArray[] = {1, 2, 3, 4, 5};
    int size = sizeof(myArray) / sizeof(myArray[0]);

    modifyArray(myArray, size);

    for (int i = 0; i < size; i++) {
        printf("%d ", myArray[i]);
    }

    return 0;
}

```
2. Передача за вказівником:
Вказівник на масив передається функції, і функція отримує доступ до оригінального масиву через цей вказівник.
Приклад:
```
#include <stdio.h>

void modifyArray(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        arr[i] *= 2;
    }
}

int main() {
    int myArray[] = {1, 2, 3, 4, 5};
    int size = sizeof(myArray) / sizeof(myArray[0]);

    modifyArray(myArray, size);

    for (int i = 0; i < size; i++) {
        printf("%d ", myArray[i]);
    }

    return 0;
}

```
**8. Що таке глобальнi i локальнi змiннi?**
Глобальні та локальні змінні - це поняття, які вказують на область видимості змінних у програмі. Область видимості визначає частину програми, в якій можна звертатися до даної змінної.
1. Глобальні змінні (Global Variables):
- Глобальні змінні оголошуються поза будь-якою функцією або блоком коду і можуть використовуватися у всій програмі.
- Вони доступні для всіх функцій та блоків коду у програмі.
- Глобальні змінні зазвичай оголошуються на рівні файлу або вже на початку програми.
2. Локальні змінні (Local Variables):
- Локальні змінні оголошуються всередині блоку коду або функції і доступні тільки в межах цього блоку чи функції.
- Вони не можуть бути використані за межами того блоку чи функції, в якому вони оголошені.
- Локальні змінні зазвичай створюються та використовуються для тимчасового зберігання даних.

**9. Основне призначення стеку в пам’ятi процесу (програми).**
Стек в пам'яті процесу (програми) - це область пам'яті, яка використовується для управління викликами функцій та локальними змінними під час виконання програми. Основне призначення стеку включає такі аспекти:
1. Управління викликами функцій:
- Кожен раз, коли в програмі викликається функція, інформація про поточний стан виклику (адреса повернення, параметри функції тощо) зберігається на стеку.
- Це дозволяє програмі повертатися до викликаючої функції після завершення викликаної функції.
2. Зберігання локальних змінних:
- Локальні змінні, оголошені всередині функцій, також зберігаються на стеку.
- Кожен виклик функції створює новий фрейм стеку, де зберігаються локальні змінні цієї функції.
- При завершенні виклику функції відповідний фрейм стеку видаляється, і пам'ять для локальних змінних вивільняється.
3. Використання стеку для передачі параметрів:
- Параметри функцій також можуть передаватися через стек. Їх значення зберігаються на стеку, і функція отримує до них доступ через відповідні позначення.
4. Керування пам'яттю:
- Стек допомагає в управлінні пам'яттю, визначаючи області, які можуть використовуватися для зберігання даних, і вивільнюючи ці області при завершенні виклику функції.
5. Швидкий доступ до даних:
- Стек є ефективним з точки зору швидкодії механізмом, оскільки доступ до даних на стеку зазвичай є швидшим, ніж до даних в інших частинах пам'яті.
